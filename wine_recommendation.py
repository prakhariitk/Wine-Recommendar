# -*- coding: utf-8 -*-
"""Wine_Recommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xRgD2cqAwuom406WKyat0Tdy7oIx9Zi8
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
import re
from PIL import Image
from IPython.display import Image

from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.feature_extraction import text 
from nltk.tokenize import RegexpTokenizer
from nltk.stem.snowball import SnowballStemmer
from sklearn.cluster import KMeans

from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import FunctionTransformer
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_predict, cross_val_score
from sklearn.metrics import confusion_matrix


# %matplotlib inline

from google.colab import files
uploaded = files.upload()

wine_data = pd.read_csv('/content/winemag-data-130k-v2.csv')
wine_data.head()

wine_data.shape

wine_data.describe()

wine_data.isnull().values.any()

wine_data[wine_data.duplicated(['title'], keep=False)].head()

wine_data.drop_duplicates(subset=['title'], keep=False, inplace=True)
wine_data.shape

wine_data['variety'].value_counts()

varieties = wine_data['variety'].value_counts()
wine_data = wine_data.loc[wine_data['variety'].isin(varieties.axes[0][:20])]
wine_data['variety'].value_counts()

wine_data.isnull().sum()

wine_data = wine_data.drop(['designation', 'region_1', 'region_2','taster_name', 'taster_twitter_handle' ], axis=1)

wine_data = wine_data.dropna(subset=['country'])

wine_data = wine_data.dropna(subset=['price'])

wine_data = wine_data.dropna(subset=['province'])

wine_data.shape

df = wine_data.copy()
df.shape

plt.title('Rating Range')
sns.countplot(df['points'])

plt.title("Which Variety is the most often reviewed")
df['variety'].value_counts().head(20).plot.bar()

sns.set_context('talk')
plt.figure(figsize=(20,10))
cnt = df['country'].value_counts().to_frame()[0:20]
#plt.xscale('log')
sns.barplot(x= cnt['country'], y =cnt.index, data=cnt, palette='colorblind',orient='h')
plt.title('Distribution of Wine Reviews of Top 20 Countries');

cnt = df.groupby(['country',]).median()['price'].sort_values(ascending=False).to_frame()

plt.figure(figsize=(20,15))
sns.pointplot(x = cnt['price'] ,y = cnt.index ,color='r',orient='h',markers='o')
plt.title('Country wise average wine price')
plt.xlabel('Price')
plt.ylabel('Country');

plt.figure(figsize=(16,8))

cnt = df.groupby(['country'])['price'].max().sort_values(ascending=False).to_frame()[:20]
g2 = sns.barplot(x = cnt['price'], y = cnt.index, palette= 'colorblind')
g2.set_title('Most expensive wine in country')
g2.set_ylabel('Country')
g2.set_xlabel('')

sns.set_context("talk")
plt.figure(figsize=(20,18))
cnt = df.groupby(['variety'])['price'].min().sort_values(ascending=True).to_frame()[:20]
g2 = sns.barplot(x = cnt['price'], y = cnt.index, palette= 'colorblind')
g2.set_title('The grapes used the cheap wines')
g2.set_ylabel('Variety')
g2.set_xlabel('')
plt.show()

plt.figure(figsize=(20,18))
cnt = df.groupby(['variety'])['price'].max().sort_values(ascending=False).to_frame()[:25]
g2 = sns.barplot(x = cnt['price'], y = cnt.index, palette= 'colorblind')
g2.set_title('The grapes used for most expensive wine')
g2.set_ylabel('Variety')
g2.set_xlabel('')
plt.show()

plt.figure(figsize=(15,9))
plt.title("Ratings by Varietal")
sns.boxplot(x='variety', y='points', data=df)

sns.set_context("talk")
plt.figure(figsize= (16,8))
plt.title('Word cloud of Description of lowest rated wine')
wc = WordCloud(max_words=1000,max_font_size=40,background_color='black', stopwords = STOPWORDS,colormap='Set1')
wc.generate(' '.join(df[df['points']==80]['description']))
plt.imshow(wc,interpolation="bilinear")
plt.axis('off')
plt.show()

plt.figure(figsize= (16,8))
plt.title('Word cloud of Description of highest rated wines')
wc = WordCloud(max_words=1000,max_font_size=40,background_color='black', stopwords = STOPWORDS,colormap='Set1')
wc.generate(' '.join(df[df['points']>=97]['description']))
plt.imshow(wc,interpolation="bilinear")
plt.axis('off')
plt.show()

plt.figure(figsize= (16,8))
plt.title('Word cloud of Description of most expensive wines')
wc = WordCloud(max_words=1000,max_font_size=40,background_color='black', stopwords = STOPWORDS,colormap='Set1')
wc.generate(' '.join(df[df['price']>=108]['description']))
plt.imshow(wc,interpolation="bilinear")
plt.axis('off')
plt.show()

plt.figure(figsize= (16,8))
plt.title('Word cloud of Description of most expensive wines')
wc = WordCloud(max_words=1000,max_font_size=40,background_color='black', stopwords = STOPWORDS,colormap='Set1')
wc.generate(' '.join(df[df['price']<=10]['description']))
plt.imshow(wc,interpolation="bilinear")
plt.axis('off')
plt.show()

plt.figure(figsize=(10,5))
c= df.corr()
sns.heatmap(c,cmap="coolwarm",annot=True)

df = df.assign(description_length = df['description'].apply(len))
fig, ax = plt.subplots(figsize=(30,10))
sns.boxplot(x='points', y='description_length', data=df)
plt.xticks(fontsize=20) # X Ticks
plt.yticks(fontsize=20) # Y Ticks
ax.set_title('Description Length per Points', fontweight="bold", size=25) # Title
ax.set_ylabel('Description Length', fontsize = 25) # Y label
ax.set_xlabel('Points', fontsize = 25) # X label
plt.show()

df.shape

df.columns

df.description_length

stemmer = SnowballStemmer('english')
tokenizer = RegexpTokenizer(r'[a-zA-Z\']+')

def tokenize(text):
    return [stemmer.stem(word) for word in tokenizer.tokenize(text.lower())]

stopwords = ['wine', 'flavor', 'flavors', 'notes', 'offers', 'enjoy', 'drink', 'bottling',
                           'really', 'reveal', 'picked', 'partner', 'thanks', 'grown', 'gain', 
                           'thanks', 'percentage', 'buy', 'mid', 'gain', 'bottle', 'amid', 'available',
                           'come', 'aspect', 'try', 'pinot', 'noir', 'chardonnay','cabernet', 'sauvignon',
                            'red','white','bordeaux', 'riesling', 'blanc','syrah','merlot',
                            'rose', 'zinfandel','malbec','nebbiolo','sangiovese', 'tempranillo','sparkling',
                            'rhone','gris', 'riesling', 'sirah', 'petite', 'petit', 'make']
stop_words = text.ENGLISH_STOP_WORDS.union(stopwords)

from random import sample
sample = df.sample(20000, random_state = 42)
sample_desc = sample['description']
sample['variety'].value_counts()

tf_vect = TfidfVectorizer(stop_words = stop_words, tokenizer=tokenize, max_features = 2000)
X_sample = tf_vect.fit_transform(sample_desc)
words_sample = tf_vect.get_feature_names()

kmeans = KMeans(n_clusters = 20, n_init = 5, n_jobs = -1)
kmeans.fit(X_sample)

common_words = kmeans.cluster_centers_.argsort()[:,-1:-16:-1]
for num, centroid in enumerate(common_words):
    print(str(num) + ' : ' + ', '.join(words_sample[word] for word in centroid))

sample['cluster'] = kmeans.labels_

clusters = sample.groupby(['cluster', 'variety']).size()
fig2, ax2 = plt.subplots(figsize = (30, 15))
sns.heatmap(clusters.unstack(level = 'variety'), ax = ax2, cmap = 'Reds')

ax2.set_xlabel('variety', fontdict = {'weight': 'bold', 'size': 24})
ax2.set_ylabel('cluster', fontdict = {'weight': 'bold', 'size': 24})
for label in ax2.get_xticklabels():
    label.set_size(16)
    label.set_weight("bold")
for label in ax2.get_yticklabels():
    label.set_size(16)
    label.set_weight("bold")

from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
nltk.download('vader_lexicon')
SIA = SentimentIntensityAnalyzer()

# Applying Model, Variable Creation
sentiment = df.sample(15000).copy()
sentiment['polarity_score']=sentiment.description.apply(lambda x:SIA.polarity_scores(x)['compound'])
sentiment['neutral_score']=sentiment.description.apply(lambda x:SIA.polarity_scores(x)['neu'])
sentiment['negative_score']=sentiment.description.apply(lambda x:SIA.polarity_scores(x)['neg'])
sentiment['positive_score']=sentiment.description.apply(lambda x:SIA.polarity_scores(x)['pos'])

sentiment['sentiment']= np.nan
sentiment.loc[sentiment.polarity_score>0,'sentiment']='POSITIVE'
sentiment.loc[sentiment.polarity_score==0,'sentiment']='NEUTRAL'
sentiment.loc[sentiment.polarity_score<0,'sentiment']='NEGATIVE'

def sentiment_analyzer_scores(sentence):
    score = SIA.polarity_scores(sentence)
    print("{:-<40} {}".format(sentence, str(score)))

print(sentiment_analyzer_scores("Hurray"))
print(sentiment_analyzer_scores("I love You"))
print(sentiment_analyzer_scores("WHAT A BORING DAY"))

df['price']

plt.figure(figsize=(14,5))
plt.suptitle('Sentiment of the reviews', size=22)

plt.subplot(121)
ax = sns.boxplot(x='sentiment', y='points', data=sentiment,palette = 'pastel')
ax.set_title("Sentiment by Points Distribution", fontsize=19)
ax.set_ylabel("Points ", fontsize=17)
ax.set_xlabel("Sentiment Label", fontsize=17)

plt.subplot(122)
ax1= sns.boxplot(x='sentiment', y='price', data=sentiment,palette = 'pastel')
ax1.set_title("Sentiment by Price Distribution", fontsize=19)
ax1.set_ylabel("Price (log) ", fontsize=17)
ax1.set_xlabel("Sentiment Label", fontsize=17)

plt.subplots_adjust(top = 0.75, wspace=.2)
plt.show()

!pip install fuzzywuzzy
from fuzzywuzzy import fuzz
from fuzzywuzzy import process

key = "pinot cabernet "
choices = df['title']
matches = (process.extract(key, choices, scorer = fuzz.ratio, limit = 5))
print("\n".join(map(str, matches)))

sample = df.sample(n=20000, random_state=42)
sample = sample.reset_index()
sample = sample.drop(['index'], axis = 1)
sample.shape

stopwords = ['wine', 'flavor', 'flavors', 'notes', 'offers', 'enjoy', 'drink', 'bottling',
                           'really', 'reveal', 'picked', 'partner', 'thanks', 'grown', 'gain', 
                           'thanks', 'percentage', 'buy', 'mid', 'gain', 'bottle', 'amid', 'available',
                           'come', 'aspect', 'try', 'pinot', 'noir', 'chardonnay','cabernet', 'sauvignon',
                            'red','white','bordeaux', 'riesling', 'blanc','syrah','merlot',
                            'rose', 'zinfandel','malbec','nebbiolo','sangiovese', 'tempranillo','sparkling',
                            'rhone','gris', 'riesling', 'sirah', 'petite', 'petit', 'make']
stop_words = text.ENGLISH_STOP_WORDS.union(stopwords)

stemmer = SnowballStemmer('english')
tokenizer = RegexpTokenizer(r'[a-zA-Z\']+')

def tokenize(text):
    return [stemmer.stem(word) for word in tokenizer.tokenize(text.lower())]

tf = TfidfVectorizer(stop_words=stop_words,tokenizer=tokenize, max_features = 2000)
tf_matrix = tf.fit_transform(sample['description'])
tf_matrix

from sklearn.metrics.pairwise import linear_kernel
cosine_sim = linear_kernel(tf_matrix, tf_matrix)
cosine = pd.DataFrame(cosine_sim)
cosine.head(10)

indices = pd.Series(sample.index, index=sample['title']).drop_duplicates()

pick_one = ''
def get_choices(key):
    
    choices = sample['title']    
    
    #gets the top five closest matches ands asks the user to pick one
    matches = (process.extract(key, choices, scorer = fuzz.ratio, limit = 5))
    print("\n Here are the 5 closest matches...Pick one for the recommender to use. \n")
    print("\n".join(map(str, matches)))
    
    global pick_one
    pick_one = input("Enter wine here: ")
    
    print("\n Okay, here are 10 other wines that are like", pick_one.title())
    
    def fuzzy_match(key):
    
        choices = sample['title']    

        #returns the top matching choice
        return process.extractOne(key, choices, scorer = fuzz.token_sort_ratio, score_cutoff = 50)[0]

    #assigning the top choice to title since that is an input for the next function
    title = fuzzy_match(pick_one)

    def get_recommendations2(title, cosine_sim=cosine_sim):

        # Get the index of the wine that matches the title
        idx = indices[title]

        # Get the pairwsie similarity scores of all wines with that wine
        sim_scores = list(enumerate(cosine_sim[idx]))

        # Sort the wines based on the similarity scores
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        # Get the scores of the 10 most similar wines
        sim_scores = sim_scores[0:11] #included the 0-th index so I can see the original wine too

        # Get the wines indices
        wine_indices = [i[0] for i in sim_scores]

        # Return the top 10 most similar wines
        return sample['title'].iloc[wine_indices]

    results = get_recommendations2(title)
    print(results)

wine = input('What wine would you like to search for?')
get_choices(wine)

def get_recommendations(title, cosine_sim=cosine_sim):
    idx = indices[title]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[0:11] #included the 0-th index so I can see the original wine too
    wine_indices = [i[0] for i in sim_scores]
    return sample['title'].iloc[wine_indices]

get_recommendations('Spangler 2013 Malbec (Southern Oregon)')

t1 = sample.loc[[17075, 17202, 518, 4958, 10217, 4904, 16708, 18538, 14569, 3523],['description', 'title']]
t1

get_recommendations("Kriter NV Eclat Carmin RosÃ© Sparkling (France)")

t2 = sample.loc[[878, 12138, 14647, 17842, 13421, 4779, 11471, 5333, 547, 13177, 4938],['description', 'title']]
t2

!pip install flask

import flask
from IPython import get_ipython

!wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip
!unzip -o ngrok-stable-linux-amd64.zip

!pip install colabcode
from colabcode import ColabCode
server = ColabCode(port=10000, code=False)

!pip install fastapi
!pip install flask
from fastapi import FastAPI
from flask import Flask, render_template, request, redirect
from typing import Dict
from fastapi import Depends, FastAPI
from pydantic import BaseModel

class input(BaseModel):
  txt: str

app = FastAPI()
@app.get('/')
def index():
    return {'message': 'Hello Kudos!!'}

@app.post('/predict')
def get_wine_recommendation(data: input):
    received = data.dict()
    txt = received('txt')
    pred_name = get_recommendations(txt)
    return {'prediction': pred_name}

from colabcode import ColabCode
server = ColabCode(port=10000, code=False)
pred_name = get_recommendations("Spangler 2013 Malbec (Southern Oregon)")
pred_name

server.run_app(app=app)

